\documentclass{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{url}
\usepackage{natbib}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{float}
\usepackage{xcolor}
\usepackage[italian]{babel}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\renewcommand{\labelenumii}{\arabic{enumi}.\arabic{enumii}}
\renewcommand{\labelenumiii}{\arabic{enumi}.\arabic{enumii}.\arabic{enumiii}}
\renewcommand{\labelenumiv}{\arabic{enumi}.\arabic{enumii}.\arabic{enumiii}.\arabic{enumiv}}

\newcommand{\emailaddr}[1]{\href{mailto:#1}{\texttt{#1}}}

\title{\LARGE
    CityTwin
}

% Consider watching:
% https://www.youtube.com/watch?v=ihxSUsJB_14
% https://www.youtube.com/watch?v=XTFWaV55uDo

\author{
    Filippo Vissani \\ \emailaddr{filippo.vissani@studio.unibo.it}
    \and 
    Eddie Barzi \\ \emailaddr{eddie.barzi@studio.unibo.it}
}

\date{September 2023}

\begin{document}

\maketitle

\begin{abstract}
    %Up to $\sim$2000 characters briefly describing the project.

    Il progetto CityTwin si propone di realizzare la simulazione di un sistema di digital twin nel contesto della smart city. In particolare, si vuole realizzare un sistema che sia in grado di catturare e rappresentare in formato digitale il comportamento delle varie entità presenti all'interno della città. Questo può portare ad una serie di benefici, alcuni dei quali vengono elencati di seguito:

    \begin{itemize}
        \item Rilevazione di possibili problematiche con intervento tempestivo e automatizzato.
        \item Riduzione del consumo energetico.
        \item Rilevazione della qualità dell'aria e dell'acqua.
        \item Analisi dell'inquinamento acustico.
        \item Ottimizzazione della mobilità urbana.
    \end{itemize}

    La simulazione sarà composta da due tipologie di nodi: i nodi Mainstay, che rappresentano la struttura portante del sistema, e i nodi Resource, che rappresentano astrazioni di sensori, attuatori o entità più complesse.

    I nodi Mainstay si occupano di scambiare informazioni con i nodi Resource, rilevare eventuali malfunzionamenti e salvare in modo persistente le informazioni rilevate dai nodi Resource. I nodi Mainstay devono essere sempre sincronizzati tra loro, in modo da poter garantire la coerenza dei dati.

    I nodi Resource, invece, si occupano di rilevare informazioni e comunicarle ai nodi Mainstay nel caso in cui vengano considerati come sensori. Nel caso in cui i nodi Resource rappresentino attuatori, invece, si occupano di ricevere informazioni dai nodi Mainstay e agire di conseguenza.

    Per la memorizzazione delle dello stato dei nodi viene disposto un servizio apposito di persistenza dei dati. Tale servizio viene utilizzato sia dai nodi Mainstay che da altri clienti, come ad esempio il pannello di controllo.

    L'utente potrà visualizzare lo stato attuale del sistema, lo storico dei dati ed eventuali statistiche, nonché interagire con il sistema tramite GUI, ad esempio per intervenire dopo la rilevazione di un incendio.

\end{abstract}

\newpage

\tableofcontents

\newpage

\section{Analisi dei Requisiti}
In questa sezione verranno delineati i vari requisiti del sistema in base alle diverse categorie di requisiti identificate. Nella fase di analisi dei requisiti, abbiamo preso il ruolo di stakeholder per comprendere appieno le esigenze degli utenti e guidare lo sviluppo del sistema. Questo approccio ci ha permesso di metterci nei panni degli utilizzatori finali e di definire con precisione le azioni chiave che gli utenti avrebbero svolto all'interno del sistema.

\subsection{Requisiti di Business}
I requisiti aziendali definiscono gli obiettivi di alto livello e la motivazione dietro lo sviluppo del software. Rispondono alla domanda "perché?" e definiscono l'importanza strategica del progetto:
\begin{enumerate}
    \item Obiettivi Strategici: Il progetto "CityTwin" mira a creare una piattaforma di simulazione e monitoraggio delle smart city per migliorare la gestione e l'ottimizzazione delle risorse urbane.
    \item Aumento dell'Efficienza Urbana: Il sistema mira a migliorare l'efficienza operativa delle città intelligenti attraverso la rappresentazione digitale delle entità e delle interazioni all'interno della città.
\end{enumerate}

\subsection{Requisiti Utente}
I requisiti utente si concentrano sull'esperienza dell'utente finale e sulla modalità di interazione con il sistema.
Gli scenari d'uso hanno permesso di definire le azioni principali che gli utenti avrebbero potuto compiere all'interno dell'applicazione.
Per rappresentare in modo efficace questi scenari e facilitare la comunicazione visiva di quello che il sistema offre all'utente, è stato definito un diagramma dei casi d'uso, mostrato in Figura \ref{fig:use-cases-diagram}. Questo diagramma ha contribuito a visualizzare in modo chiaro ed esauriente le attività degli utenti e le interazioni con il sistema.

\begin{enumerate}
    \item L'utente deve avere a disposizione una GUI (Control Panel) con le seguenti funzionalità:
          \begin{enumerate}
              \item Deve mostrare lo stato attuale dei nodi Mainstay e Resource del sistema.
              \item Deve mostrare la posizione delle risorse nella città, indicandone il nome e lo stato (online/offline).
              \item Deve mostrare un grafico che rappresenti il numero di nodi Mainstay e Resource online nel tempo, sulla base dei dati rilevati
                    dal servizio di persistenza.
          \end{enumerate}
    \item L'utente deve avere a disposizione una GUI (River Monitor) con le seguenti funzionalità:
          \begin{enumerate}
              \item Deve mostrare lo stato attuale del River Monitor (Safe, Warned, Evacuating).
              \item Deve mostrare i sensori monitorati con il relativo livello dell'acqua.
              \item Deve mostrare il valore di soglia dell'acqua sopra la quale il River Monitor passa allo stato di "Warned".
              \item Deve mettere a disposizione un pulsante per passare allo stato di "Evacuating" e un pulsante per tornare allo stato di "Safe".
          \end{enumerate}
    \item L'utente deve avere la possibilità di aggiungere o rimuovere nuovi nodi Resource in tempo reale, senza che questo comprometta il funzionamento del sistema. Questa flessibilità consente di adattare il sistema alle mutevoli esigenze delle smart cities.
\end{enumerate}
\begin{figure}[H]
    \centering
    \caption{Diagramma dei casi d'uso.}
    \includegraphics[width=0.8\textwidth]{../assets/images/use-cases-diagram.png}
    \label{fig:use-cases-diagram}
\end{figure}


\subsection{Requisiti Funzionali}
I requisiti funzionali delineano le funzioni specifiche del sistema, cioè cosa il sistema deve fare:
\begin{enumerate}
    \item I nodi Mainstay sono la struttura portante dell'intero sistema:
          \begin{enumerate}
              \item Ricevono informazioni dai nodi Resource che modellano sensori.
              \item Comunicano informazioni ai nodi Resource che modellano attuatori.
              \item Rilevano i malfunzionamenti dei nodi Resource.
              \item Rilevano i malfunzionamenti degli altri nodi Mainstay.
              \item Si occupano di salvare le informazioni contattando il servizio di persistenza.
              \item Non devono conoscere a prescindere le tipologie dei nodi Resource.
              \item Devono disporre di una struttura dati distribuita che permetta di memorizzare le informazioni rilevanti:
                    \begin{enumerate}
                        \item La struttura dati deve essere sincronizzata tra i nodi Mainstay.
                        \item La struttura dati deve mantenere la consistenza dei dati nel tempo.
                    \end{enumerate}
          \end{enumerate}
    \item I nodi Resource:
          \begin{enumerate}
              \item Rappresentano astrazioni di:
                    \begin{enumerate}
                        \item Sensori.
                        \item Attuatori.
                        \item Entità più complesse, come stazioni di controllo, che possono anche impiegare interfacce grafiche.
                    \end{enumerate}
              \item Fanno riferimento ad uno dei nodi Mainstay per ottenere o comunicare informazioni.
              \item Possono essere aggiunti o rimossi in tempo reale.
          \end{enumerate}
    \item Deve essere presente un servizio di persistenza dei dati che permetta di salvare in modo persistente:
          \begin{enumerate}
              \item Lo stato dei nodi Mainstay.
              \item Lo stato dei nodi Resource.
          \end{enumerate}
    \item Il malfunzionamento di un nodo non deve compromettere il funzionamento del sistema.
    \item Deve poter essere possibile introdurre nuovi moduli senza dover modificare i componenti esistenti.
    \item Vengono previsti i seguenti moduli per i nodi Resource:
          \begin{enumerate}
              \item Sensore per la rilevazione di piogge acide. Il sensore deve essere in grado di rilevare il valore di pH dell'acqua piovana, compreso tra 0 e 14.
              \item Sensore per l'analisi della qualità dell'aria. Il sensore deve essere in grado di rilevare i seguenti parametri chiave:
                    \begin{enumerate}
                        \item \label{itm:pm10} Concentrazione di PM10 (Particolato inferiore ai 10 micrometri).
                        \item \label{itm:pm25} Concentrazione di PM2,5 (Particolato inferiore ai 2,5 micrometri. Si noti che è un sottoinsieme del PM10).
                        \item \label{itm:NOx} Concentrazione di NOx (Ossidi di azoto).
                    \end{enumerate}
                    Si deve inoltre considerare che si andrà a utilizzare un sensore economico prefabbricato a basso consumo energetico, in grado di comunicare i dati rilevati tramite un protocollo di rete.
              \item Sensore per la rilevazione dell'inquinamento acustico, con le seguenti caratteristiche:
                    \begin{enumerate}
                        \item \label{itm:dB} Le letture devono variare in un intervallo di valori rappresentativi di un ambiente urbano, da 40 a 100 decibel (dB).
                        \item \label{itm:dBDescription} Oltre al valore in decibel, il sensore deve fornire una descrizione corrispondente al livello di rumore.
                    \end{enumerate}
              \item Modulo per la rilevazione del livello dell'acqua di un fiume e possibilità di intervento:
                    \begin{enumerate}
                        \item Sensore per la rilevazione degli allagamenti: il sensore deve periodicamente misurare il livello dell'acqua e comunicare il valore rilevato al nodo Mainstay.
                        \item Pannello di controllo per l'intervento in caso di allagamento, con le seguenti caratteristiche:
                              \begin{enumerate}
                                  \item Soglia di allagamento configurabile.
                                  \item Possibilità di controllare più sensori.
                                  \item Possibilità di assumere tre stati:
                                        \begin{itemize}
                                            \item Safe quando non c'è pericolo.
                                            \item Warned quando il livello dell'acqua supera la soglia di allagamento.
                                            \item Evacuating quando il livello dell'acqua supera la soglia di allagamento e l'utente ha premuto il pulsante di evacuazione.
                                        \end{itemize}
                                  \item Mostrare lo stato attuale del River Monitor.
                                  \item Passaggio in automatico allo stato Warned quando il valore della maggioranza dei sensori supera la soglia di allagamento.
                                  \item Possibilità di intervenire passando in stato Evacuating quando il sistema è Warned.
                                  \item Possibilità di intervenire tornando in stato Safe quando il sistema è Evacuating.
                              \end{enumerate}
                    \end{enumerate}
          \end{enumerate}
\end{enumerate}

\subsection{Requisiti Non Funzionali}
I requisiti non funzionali definiscono attributi di qualità, vincoli e proprietà generali del sistema:
\begin{enumerate}
    \item Affidabilità: L'affidabilità e la resilienza sono due aspetti cruciali del sistema "CityTwin". In caso di guasti hardware o malfunzionamenti dei nodi, il sistema deve essere in grado di mantenere la continuità delle operazioni fondamentali. A tale scopo, è prevista l'implementazione di un meccanismo di ridondanza, in cui i dati sono presenti in più istanze di nodi Mainstay.
    \item Performance: Il sistema deve rispondere tempestivamente alle richieste dell'utente (in media entro 1 secondo) e gestire grandi quantità di dati in tempo reale (almeno 30 risorse).
    \item Modularità: Il sistema deve essere realizzato in moduli separati, in modo da poter essere facilmente estendibile.
\end{enumerate}

\subsection{Requisiti di Implementazione}
I requisiti di implementazione riguardano gli aspetti tecnologici e metodologici dell'implementazione del sistema:
\begin{enumerate}
    \item Linguaggio di Programmazione: Il sistema deve essere realizzato utilizzando il linguaggio Scala 3\cite{scala}.
    \item Architettura Basata su Attori: L'implementazione deve seguire il paradigma ad attori utilizzando il framework Akka\cite{akka} per gestire l'interazione tra i nodi.
    \item Tecnologie di Persistenza: Il modulo di persistenza dei dati deve essere implementato utilizzando MongoDB\cite{mongodb} per garantire la memorizzazione affidabile dei dati rilevati.
    \item Documentazione del Codice: Il codice deve essere adeguatamente documentato per consentire una comprensione chiara e agevolare la manutenzione futura.
\end{enumerate}

\section{Progettazione}

\subsection{Architettura del Sistema}

L'architettura del sistema, presentata in Figura \ref{fig:core-component-diagram}, è organizzata intorno a componenti interconnessi che consentono il monitoraggio e la gestione delle entità presenti all'interno della città. Ogni componente svolge ruoli specifici all'interno del sistema e interagisce attraverso interfacce ben definite.

\begin{figure}[H]
    \caption{Diagramma dei componenti del sistema e delle loro dipendenze.}
    \includegraphics[width=\textwidth]{../assets/images/core-component-diagram.png}
    \label{fig:core-component-diagram}
\end{figure}

In Figura \ref{fig:nodes-component-diagram} viene presentata l'architettura dei componenti in esecuzione e dei protocolli di rete utilizzati. Il sistema è costituito da un insieme di nodi \textit{Mainstay} e \textit{Resource} che comunicano tra loro attraverso il protocollo \textit{Akka}. Inoltre, i nodi \textit{Mainstay} comunicano con il servizio di persistenza attraverso il protocollo \textit{HTTP}.
I nodi che comunicano utilizzando il protocollo \textit{Akka} sono \textit{Actor System} organizzati in un cluster, in modo da poter garantire la scalabilità del sistema.

\begin{figure}[H]
    \caption{Diagramma dei componenti in esecuzione e dei protocolli di rete utilizzati.}
    \includegraphics[width=\textwidth]{../assets/images/nodes-component-diagram.png}
    \label{fig:nodes-component-diagram}
\end{figure}

\subsubsection{Core}
Il componente centrale del sistema è il \textit{Core}, responsabile della gestione dell'elaborazione dati, del coordinamento delle attività e della comunicazione tra gli altri componenti. Il Core funge da mediatore tra le varie risorse presenti all'interno della città, ricevendo dati dai sensori e inviandoli al servizio di persistenza.

L'architettura del modulo \textit{Core} (Figura \ref{fig:core-class-diagram}) è costituita da diversi attori, ognuno dei quali svolge un ruolo specifico nel processo di acquisizione, gestione e comunicazione dei dati relativi alle risorse.

\textit{Resource Actor} è responsabile della gestione della risorsa, indipendentemente dal fatto che essa sia un sensore o un attuatore. Comunica con il \textit{Mainstay Actor} per ottenere o mandare lo stato delle risorse. È in grado di ricevere comandi e cambiamenti relativi alle risorse.

Il \textit{Mainstay Actor} si occupa di tenere in piedi l'intero sistema distribuito. Esso scambia lo stato delle risorse con il \textit{Resource Actor} e comunica con il \textit{Persistence Service Driver Actor} per salvare i dati nel servizio di persistenza. Inoltre, il \textit{Mainstay Actor} è responsabile della sincronizzazione dei nodi \textit{Mainstay}.

Il \textit{Nodes Observer Actor} monitora gli stati dei nodi all'interno del sistema e aggiorna il \textit{Mainstay Actor} sulla base del cambiamento di stato dei nodi.

L'attore \textit{Persistence Service Driver} è responsabile della gestione delle operazioni di persistenza dei dati. Comunica con il \textit{Mainstay Actor} per pubblicare nuovi dati al servizio di persistenza.

L'architettura prevede interazioni chiare e ben definite tra gli attori attraverso l'utilizzo di comandi specifici.

Il \textit{Resource Actor} comunica con il \textit{Mainstay Actor} utilizzando comandi come \textit{AskResourcesState}, \textit{AskAllResourcesState} e \textit{UpdateResources}. Queste interazioni consentono al \textit{Resource Actor} di ottenere informazioni sullo stato delle risorse e di aggiornare lo stato stesso.

Il \textit{Mainstay Actor} comunica con il \textit{Persistence Service Driver Actor} utilizzando comandi come \textit{PostMainstay} e \textit{PostResource}. Queste interazioni consentono al \textit{Mainstay Actor} di inviare nuovi dati al servizio di persistenza.

\begin{figure}[H]
    \caption{Diagramma delle classi del modulo \textit{Core}.}
    \includegraphics[width=\textwidth]{../assets/images/core-class-diagram.png}
    \label{fig:core-class-diagram}
\end{figure}

\subsubsection{Componenti Monitor}
I diversi monitor ambientali, come l'\textit{Acid Rain Monitor}, l'\textit{Air Quality Monitor}, il \textit{Noise Pollution Monitor} e il \textit{River Monitor}, costituiscono le fonti primarie di dati. Ciascun monitor raccoglie misurazioni specifiche e invia queste informazioni al \textit{Core} tramite l'interfaccia \textit{Resource}. Questa comunicazione consente al \textit{Core} di elaborare i dati e fornire una visione completa delle condizioni ambientali.

\paragraph{Sensori}\label{par:Sensori}
L'architettura dei sensori, quindi del \textit{NoiseSensor, AcidRainSensor, AirSensor} e \textit{FloodSensor}, prevede una stretta collaborazione con il \textit{Resource Actor}, un componente principale del sistema. I sensori generano periodicamente un messaggio di tick verso se stessi, avviando il processo di generazione dei dati. Una volta ottenuti i dati, i sensori li inviano al \textit{Resource Actor}, che si occupa di comunicare i dati al \textit{Mainstay Actor}. In Figura \ref{fig:sensor-resourceactor-interaction-diagram} viene presentato il diagramma di sequenza per l'interazione tra un sensore e il relativo \textit{Resource Actor}.

\begin{figure}[H]
    \centering
    \caption{Diagramma di sequenza per l'interazione tra un sensore e il relativo \textit{Resource Actor}.}
    \includegraphics[width=0.6\textwidth]{../assets/images/sensor-resourceactor-interaction-diagram.png}
    \label{fig:sensor-resourceactor-interaction-diagram}
\end{figure}

\paragraph{River Monitor}
Il "River Monitor" è un complesso sistema progettato per rilevare, monitorare e rispondere alle situazioni di alluvione in aree sensibili. Questo paragrafo descrive in dettaglio il design concettuale del sistema, delineando i componenti chiave e il loro ruolo all'interno dell'architettura complessiva.
\subparagraph{Architettura}
Nel sistema sistema di monitoraggio del fiume sono presenti i seguenti nodi \textit{Resource}, i quali non comunicano quindi direttamente tra di loro ma ognuno attraverso il proprio \textit{Resource Actor}:

\begin{enumerate}
    \item \textbf{Flood Sensor}: Sensore che rileva il livello dell'acqua del fiume, descritto nel paragrafo \ref{par:Sensori}.

    \item \textbf{River Monitor Actor}: Il \textit{River Monitor} è un componente centrale del sistema. Ha il compito di monitorare i dati provenienti dai sensori di alluvione, valutare le condizioni correnti e prendere decisioni in base ai dati ricevuti. Il \textit{River Monitor} può attivare allarmi e avviare procedure di evacuazione. Per rappresentare lo stato del \textit{River Monitor} è stato introdotto il \textit{River Monitor State Actor}, il quale riceve messaggi dal \textit{River Monitor Actor} riguardo ai cambiamenti di stato, come la necessità di passare in stato di allarme o il passaggio allo stato di evacuazione. Il diagramma di sequenza in Figura \ref{fig:rivermonitor-resourceactor-interaction-diagram} illustra l'interazione tra il \textit{River Monitor Actor}, il \textit{River Monitor State Actor} e il \textit{Resource Actor}.

    \item \textbf{View}: La \textit{View} rappresenta l'interfaccia utente dell'applicazione. Fornisce una rappresentazione visiva dello stato del \textit{River Monitor} e consente agli utenti di interagire con il sistema. Gli utenti possono visualizzare lo stato corrente, avviare procedure di evacuazione o segnalare zone come "evacuate" dopo aver avviato l'evacuazione. Nel diagramma di sequenza in Figura \ref{fig:view-interaction-diagram} viene illustrata l'interazione tra la \textit{View}, il \textit{View Actor} e il \textit{Resource Actor}.
\end{enumerate}

\begin{figure}[H]
    \caption{Diagramma di sequenza per l'interazione tra River Monitor Actor, River Monitor State Actor e Resource Actor.}
    \includegraphics[width=\textwidth]{../assets/images/rivermonitor-resourceactor-interaction-diagram.png}
    \label{fig:rivermonitor-resourceactor-interaction-diagram}
\end{figure}

\begin{figure}[H]
    \caption{Diagramma di sequenza per l'interazione tra View, View Actor e Resource Actor.}
    \includegraphics[width=\textwidth]{../assets/images/view-interaction-diagram.png}
    \label{fig:view-interaction-diagram}
\end{figure}

\subparagraph{Scenario operativo}
Il ciclo operativo all'interno del sistema di monitoraggio del fiume è il seguente:

\begin{enumerate}
    \item I sensori di alluvione rilevano continuamente i livelli dell'acqua e inviano i dati al \textit{Resource Actor}.

    \item Il \textit{River Monitor Actor} richiede al \textit{Resource Actor} lo stato delle risorse che sta monitorando, ovvero i sensori e la view. In condizioni normali, il \textit{River Monitor} è in stato \textit{Safe}.

    \item Il \textit{River Monitor Actor} valuta le misurazioni dei sensori per determinare se è necessario passare allo stato di allarme. Nello specifico, comunica al \textit{River Monitor State Actor} di passare allo stato di \textit{Warned} se il livello dell'acqua della maggior parte dei sensori supera una soglia critica.

    \item Il \textit{River Monitor Actor} controlla le risorse relative alla view perché se l'utente ha avviato una procedura di evacuazione (possibile solo se il \textit{River Monitor State Actor} è in stato di allarme), il \textit{River Monitor State Actor} cambia il suo stato in \textit{Evacuating}. dallo stato di \textit{Evacuating} il \textit{River Monitor State Actor} può passare allo stato di \textit{Evacuated} se l'utente ha segnalato che la zona è stata evacuata. in questo caso il \textit{River Monitor State Actor} torna allo stato \textit{Safe}.

    \item A questo punto il \textit{River Monitor State Actor} comunica al \textit{Resource Actor} il suo stato e i sensori monitorati, in modo che queste informazioni possano essere visualizzate nella \textit{View}.

    \item La \textit{View} visualizza lo stato corrente del \textit{River Monitor} agli utenti e consente loro di agire, avviando procedure di evacuazione e di fine evacuazione quando lo stato del \textit{River Monitor} lo consente.
\end{enumerate}

Il diagramma degli stati in Figura \ref{fig:river-monitor-state-diagram} mostra i possibili stati che può assumere il sistema \textit{River Monitor}.

\begin{figure}[H]
    \centering
    \caption{Diagramma degli stati che può assumere la risorsa River Monitor.}
    \includegraphics[width=\textwidth]{../assets/images/river-monitor-state-diagram.png}
    \label{fig:river-monitor-state-diagram}
\end{figure}

\subsubsection{Control Panel}
Il \textit{Control Panel} è l'interfaccia utente principale attraverso cui gli utenti interagiscono con il sistema. Comunica con il \textit{Core} per ottenere dati sullo stato ambientale e sul sistema nel suo complesso. Inoltre, il pannello di controllo richiede al servizio di persistenza lo storico dei dati in modo da poterli elaborare per ottenere delle statistiche.

\subsubsection{Persistence Service}
Il \textit{Persistence Service} gestisce la persistenza dei dati nel sistema. Comunica con il \textit{Core} attraverso le interfacce \textit{Post Resource} e \textit{Post Mainstay} per ricevere e salvare i dati relativi alle risorse. Analogamente, le interfacce \textit{Get Mainstay} e \textit{Get Resource }consentono di richiedere i dati al servizio di persistenza.

\subsection{Interazioni dei Componenti}

Il comportamento generale del sistema viene definito sulla base di una serie di interazioni tra i componenti. In particolare, le interazioni possono essere raggruppate per definire un determinato aspetto di tale comportamento.

\subsubsection{Aggiornamento sullo Stato dei Nodi}

Lo scambio di messaggi tra \textit{Nodes Observer Actor} e \textit{Mainstay Actor} (Figura \ref{fig:core-nodes-state-sequence-diagram}) è volto a mantenere aggiornato quest'ultimo sullo stato generale dei nodi del sistema. Nel momento in cui il \textit{Mainstay Actor} riceve un aggiornamento sui nodi, esso aggiorna il proprio stato e lo comunica al \textit{Persistence Service Driver Actor}, che si occupa di rendere persistenti i dati tramite il servizio di persistenza.

\begin{figure}[H]
    \caption{Diagramma di sequenza per l'aggiornamento sullo stato dei nodi del sistema.}
    \includegraphics[width=\textwidth]{../assets/images/core-nodes-state-sequence-diagram.png}
    \label{fig:core-nodes-state-sequence-diagram}
\end{figure}

\subsubsection{Aggiornamento sullo Stato delle Risorse}

Lo scambio di messaggi tra \textit{Resource Actor} e \textit{Mainstay Actor} (Figura \ref{fig:core-resource-state-exchange-sequence-diagram}) è utile a:
\begin{itemize}
    \item Ottenere lo stato delle altre risorse e comunicare il proprio nel caso un cui il nodo \textit{Resource} modella un attuatore.
    \item Comunicare lo stato della risorsa nel caso un cui il nodo \textit{Resource} modella un sensore.
\end{itemize}

In ogni caso, quando il \textit{Mainstay Actor} riceve un aggiornamento, lo comunica al servizio di persistenza tramite il \textit{Persistence Service Driver Actor}.

\begin{figure}[H]
    \caption{Diagramma di sequenza per lo scambio dello stato delle risorse.}
    \includegraphics[width=\textwidth]{../assets/images/core-resource-state-exchange-sequence-diagram.png}
    \label{fig:core-resource-state-exchange-sequence-diagram}
\end{figure}

\subsubsection{Sincronizzazione dei Nodi Mainstay}

Come detto precedentemente, i nodi \textit{Mainstay} sono i pilastri portanti dell'intero sistema e si occupano della gestione dei dati riguardanti le risorse e i nodi. I nodi \textit{Mainstay} devono essere sempre sincronizzati tra loro, in modo da poter garantire la coerenza dei dati. Per questo motivo, i nodi \textit{Mainstay} si sincronizzano ogni volta che una risorsa manda il suo stato ad uno di questi. In Figura \ref{fig:core-mainstays-sync-sequence-diagram} viene presentato il diagramma di sequenza per la sincronizzazione dei nodi \textit{Mainstay}.

\begin{figure}[H]
    \caption{Diagramma di sequenza per la sincronizzazione dei nodi Mainstay.}
    \includegraphics[width=\textwidth]{../assets/images/core-mainstays-sync-sequence-diagram.png}
    \label{fig:core-mainstays-sync-sequence-diagram}
\end{figure}

\subsubsection{Aggiornamento del Pannello di Controllo}

Il comportamento del \textit{Control Panel} (Figura \ref{fig:control-panel-sequence-diagram}) viene modellato come un caso particolare di risorsa che comunica con il \textit{Mainstay Actor} per ottenere lo stato delle risorse e dei nodi. Inoltre, il \textit{Control Panel} comunica con il servizio di persistenza per ottenere lo storico dei dati e calcolare le statistiche.

\begin{figure}[H]
    \caption{Diagramma di sequenza per l'aggiornamento del pannello di controllo.}
    \includegraphics[width=\textwidth]{../assets/images/control-panel-sequence-diagram.png}
    \label{fig:control-panel-sequence-diagram}
\end{figure}

\section{Dettagli Implementativi}

\subsection{Tecnologie Utilizzate}

\subsubsection{Scala 3}

Scala 3 è una versione successiva del linguaggio di programmazione Scala, progettato per migliorare e semplificare ulteriormente l'esperienza di programmazione funzionale e orientata agli oggetti. È un linguaggio staticamente tipizzato che unisce caratteristiche provenienti da diversi paradigmi di programmazione, consentendo agli sviluppatori di scrivere codice conciso ed elegante mentre sfruttano la potenza dei tipi statici.

\subsubsection{Simple Build Tool (SBT)}

SBT\cite{sbt} è uno strumento di build e gestione delle dipendenze ampiamente utilizzato nella comunità di sviluppo software in linguaggio Scala. È stato creato per semplificare il processo di compilazione, test e distribuzione delle applicazioni Scala.

\subsubsection{Akka}

Akka è un toolkit open-source scritto in Scala che offre un modello di programmazione per costruire applicazioni distribuite, concorrenti e reattive basate su attori. Gli attori sono unità fondamentali di elaborazione in Akka e rappresentano entità concorrenti leggere che comunicano tra loro attraverso messaggi. Questo modello di programmazione facilita la gestione dell'elaborazione parallela e distribuita in modo efficiente.

\subsubsection{Node.js}

Node.js\cite{nodejs} è una piattaforma open-source basata sul motore JavaScript V8 di Google, progettata per consentire l'esecuzione di codice JavaScript lato server. Prima dell'avvento di Node.js, JavaScript era principalmente utilizzato all'interno dei browser per creare interazioni dinamiche nelle pagine web. Tuttavia, Node.js ha esteso il suo utilizzo consentendo di eseguire codice JavaScript anche sul server, aprendo la strada a numerose possibilità di sviluppo web e applicativo.

\subsubsection{Node Package Manager (NPM)}

NPM\cite{npm} è un gestore di pacchetti che permette agli sviluppatori di installare, condividere e gestire librerie e pacchetti di terze parti. Questo ecosistema di pacchetti offre una vasta gamma di strumenti e librerie che semplificano lo sviluppo.

\subsubsection{MongoDB}

MongoDB è un database NoSQL ampiamente utilizzato per gestire e archiviare grandi quantità di dati, inclusi dati non strutturati, semi-strutturati e strutturati. È progettato per essere flessibile, scalabile e performante, ed è particolarmente adatto per applicazioni che richiedono un'archiviazione e un accesso veloce a dati complessi e eterogenei.

\subsubsection{Docker}

Docker\cite{docker} è una tecnologia di virtualizzazione leggera e di containerizzazione che consente di creare, distribuire e gestire applicazioni e servizi in ambienti isolati noti come "container". Questi container includono tutto ciò di cui un'applicazione ha bisogno per essere eseguita, come il codice, le librerie, le dipendenze e le variabili d'ambiente, il tutto condiviso su una base immutabile. Questo concetto di containerizzazione rende Docker un approccio efficace per sviluppare, testare e distribuire applicazioni in modo rapido e consistente su diverse piattaforme.

\subsubsection{Servizio FAAS Microsoft Azure Functions}

Il servizio Azure Functions\cite{azurefunctions} (Funzioni di Azure) è una soluzione di elaborazione serverless offerta da Microsoft Azure\cite{microsoftazure}. Questo servizio consente agli sviluppatori di scrivere, distribuire ed eseguire rapidamente codice in risposta ad eventi specifici senza preoccuparsi dell'infrastruttura sottostante. Le Azure Functions sono progettate per essere altamente scalabili e reattive, rendendole ideali per scenari in cui è richiesta una risposta rapida a eventi come richieste HTTP, scadenze temporali o trigger di database.

\subsection{Problematiche Riscontrate e Soluzioni Adottate}

\subsubsection{Serializzazione delle Strutture Dati}

La serializzazione in Akka è il processo di convertire oggetti Scala in un formato che può essere trasmesso attraverso la rete e quindi ricostruito in un oggetto equivalente. Questo è particolarmente importante in un ambiente basato su attori, in cui i messaggi vengono inviati tra attori in diversi processi o nodi. Lo scambio di messaggi prevede l'utilizzo di strutture dati, che in un sistema distribuito devono essere serializzate prima di essere inviate.

Durante il processo di sviluppo si sono presentati problemi di serializzazione delle \verb|HashMap[A, B]| (dove \verb|A| e \verb|B| sono tipi generici), per questo motivo si è scelto di convertire le \verb|HashMap[A, B]| in \verb|Set[(A, B)]| per lo scambio di messaggi tra attori.

Un altro tipo di struttura dati che non è possibile serializzare direttamente è l'enumerazione di Scala 3. Per questo motivo, si è scelto di utilizzare un'enumerazione di Scala 2, che è serializzabile.

Esempio di enumerazione in Scala 3:

\begin{lstlisting}[language=Scala]
    enum ResourceType:
        case Act
        case Sense
\end{lstlisting}

Esempio di enumerazione in Scala 2:

\begin{lstlisting}[language=Scala]
    object ResourceType extends Enumeration:
        type ResourceType = Value
        val Act, Sense = Value
\end{lstlisting}

\subsubsection{Rappresentazione dello Stato delle Risorse}

I nodi \textit{Mainstay} sono stati concepiti per essere generici e indipendenti dagli altri moduli del sistema. Per questo motivo non conoscono il tipo di risorse presenti a runtime e quindi non possono interpretarne lo stato. Questa risulta una problematica nel momento in cui lo stato della risorsa va serializzato per essere inviato ad un nodo \textit{Mainstay}.

In origine il tipo dello stato della risorsa è stato definito come \verb|Any|, ma questo ha portato a problemi di serializzazione. Per risolvere questo problema, si è scelto di tipizzare lo stato come \verb|String|, in modo che esso possa essere definito in formato JSON.

\subsection{Implementazione dei Moduli Monitor}
In questa sezione verrà illustrata l'implementazione delle parti più significative dei moduli di monitoraggio dell'aria, delle piogge acide, dell'inquinamento acustico e delle alluvioni.

\subsubsection{De/Serializzazione dei Dati prodotti dalle risorse}
Ogni risorsa viene rappresentata nel sistema come istanza della classe \textit{ResourceState}, la quale contiene le seguenti informazioni:
\begin{itemize}
    \item \textbf{name:} Nome della risorsa.
    \item \textbf{position:} Posizione della risorsa.
    \item \textbf{state:} Dati prodotti dalla risorsa.
    \item \textbf{resourceType:} Tipo della risorsa.
    \item \textbf{nodeState:} Stato del nodo.
\end{itemize}
Ciascuna risorsa potrebbe però generare dei dati di tipo diverso, quindi è necessario trovare un modo per rappresentare questi dati in maniera generica.
Si è deciso di utilizzare il campo \textit{state} come \textit{String} in formato JSON, in modo che possa essere facilmente letto da altre risorse.

In questo modo, la stringa JSON potrà essere facilmente deserializzata dalle risorse che ne conoscono il significato e intendono utilizzare i dati per le proprie operazioni.

\paragraph{Passi per la de/serializzazione}
Per la serializzazione e deserializzazione dei dati si è scelto di utilizzare la libreria \textit{upickle}\cite{upickle}, che permette di convertire facilmente e in modo efficiente le classi Scala in formato JSON e viceversa.

Per utilizzare questa libreria è necessario dichiarare le classi che si intendono serializzare e deserializzare come \textit{derives} di \textit{upickle.default.ReadWriter}, come mostrato nel seguente listato:
\begin{lstlisting}[language=Scala]
    import upickle.default.ReadWriter
    case class FloodSensorData(waterLevel: Float) derives ReadWriter
\end{lstlisting}
In questo modo vengono generati automaticamente i metodi \textit{read} e \textit{write} che vengono utilizzati per serializzare e deserializzare correttamente instanze di quella classe. Sarà sufficiente chiamare quindi il metodo \textit{write} per serializzare un'istanza di \textit{FloodSensorData} in formato JSON e il metodo \textit{read} per deserializzare una stringa JSON in un'istanza di \textit{FloodSensorData}.

Nel seguente listato viene mostrato un esempio:
\begin{lstlisting}[language=Scala]
    // Il sensore genera un'istanza di FloodSensorData e la serializza
    val data = FloodSensorData(waterLevel)
    val dataAsJsonString = write(data)

    // Il messaggio viene mandato sotto forma di stringa JSON.

    // La misurazione viene quindi ricevuta e deserializzata dal RiverMonitor
    try {
        val data = read(dataAsJsonString)
    } catch {
        case _ => // Errore nella deserializzazione
    }
    
\end{lstlisting}
Si noti come è importante gestire eventuali errori nella deserializzazione, in quanto la stringa JSON potrebbe aver subito delle modifiche durante la trasmissione che la rendono non più valida.

\subsubsection{Sensori}
Tutti e quattro i moduli Monitor implementano ognuno un proprio sensore, rappresentato da un attore specifico, che simula il comportamento di un sensore reale. I sensori dei quattro moduli seguono una struttura simile nell'implementazione, basata sull'utilizzo di attori e su un timer per la generazione periodica dei dati. Ciò che cambia da un sensore all'altro è il tipo di dato che viene generato e inviato al sistema.
Nel seguente listato viene mostrata l'implementazione di \textit{Flood Sensor Actor,
    Noise Sensor Actor, Air Sensor Actor} e \textit{Acid Rain Sensor Actor}, senza andare nel dettaglio dei dati generati.

\begin{lstlisting}[language=Scala]
object SensorActor:
  def apply(sensor: Sensor): Behavior[SensorActorCommand] =
    Behaviors.setup { ctx =>
      val resourceActor = ctx.spawnAnonymous(ResourceActor())
      Behaviors.withTimers { timers =>
        timers.startTimerAtFixedRate(Tick, TickInterval)
        Behaviors.receiveMessage {
          case Tick =>
            // Generate data
            val dataAsJson = generateMeasurementData()
            val resourceState = ResourceState(
              Some(sensor.name),
              Some(sensor.position),
              Some(dataAsJson),
              Set(ResourceType.Sense)
            )
            // Send generated ResourceState to ResourceActor
            resourceActor ! ResourceChanged(resourceState)
            Behaviors.same
        }
      }
    }
\end{lstlisting}

\paragraph{Generazione dei Dati}
Come i dati vengono generati è illustrato di seguito:
\begin{itemize}
    \item \textbf{Air Sensor Actor:} Questo attore è stato progettato per simulare l'utilizzo di un sensore fisico reale che possa comunicare solo attraverso un protocollo di rete. Per questo motivo, il sensore non genera direttamente i dati, ma li ottiene interagendo con una funzione su Azure che simula il comportamento del sensore. L'\textit{Air Sensor Actor} richiede i dati alla funzione attraverso una richiesta HTTP GET e la funzione risponde con i dati in formato JSON. Un esempio di risposta è la seguente stringa: \textit{\{"pm10":46.29966, "pm25":33.35241, "nox":76.84502\}}. Per assicurarsi che i dati ricevuti siano in un formato valido, la stringa JSON viene deserializzata in un'istanza di \textit{AirSensorData}, la \textit{Case Class} che rappresenta i dati rilevati dal sensore.
    \item \textbf{Acid Rain Sensor Actor:} Questo attore genera i dati in modo casuale. I dati generati sono valori di pH compresi tra 0 e 14. Per rappresentare i dati di questo sensore viene utilizzata la \textit{Case Class AcidRainSensorData}. L'instanza della \textit{Case Class} viene poi serializzata in formato JSON e inviata al \textit{Resource Actor}. Un esempio di valore generato è la seguente stringa in formato JSON: \textit{\{"ph":7.0\}}.
    \item \textbf{Noise Sensor Actor:} Questo attore genera il valore di decibel in modo casuale, con un range da 40 a 100 decibel (dB), e una descrizione relativa al livello di rumore. Viene prodotta un'istanza di \textit{NoiseSensorData} e un esempio di dato generato dopo la serializzazione è la seguente stringa in formato JSON: \textit{\{"value":65, "description":"Moderate noise"\}}.
    \item \textbf{Flood Sensor Actor:} Questo attore genera il valore di livello dell'acqua in modo casuale, con un range da 0 a 20. Per rappresentare i dati di questo sensore viene utilizzata la \textit{Case Class FloodSensorData}. Un esempio di dato generato dopo la serializzazione è la seguente stringa in formato JSON: \textit{\{"waterLevel":7.2\}}.
\end{itemize}

\subsubsection{River Monitor Actor}
Il \textit{River Monitor Actor} fa parte del modulo \textit{River Monitor}.
Si occupa di ricevere i dati di eventuali sensori e attuatori (view) e di deserializzarli per decidere il comportamento da adottare.

I dati che questa risorsa deve comunicare per rappresentare il proprio stato sono mostrati nel seguente listato, il quale mostra la \textit{Case Class} \textit{RiverMonitorData}:
\begin{lstlisting}[language=Scala]
    case class RiverMonitorData(
        riverMonitorState: RiverMonitorState,
        threshold: Float,
        monitoredSensors: Option[Map[String, Map[String, String]]]
    ) derives ReadWriter
\end{lstlisting}

\section{Validazione del Sistema}

\subsection{Testing dei Moduli Sviluppati in Scala 3}

Per testare i moduli sviluppati in Scala 3 si è scelto di utilizzare il framework di testing ScalaTest\cite{scalatest} in combinazione con il TestKit fornito da Akka.

ScalaTest è un framework di testing per il linguaggio di programmazione Scala. È progettato per semplificare il processo di scrittura e esecuzione dei test nelle applicazioni Scala, fornendo una varietà di stili di testing e utilità per rendere più facile il testing delle applicazioni.

Per testare efficacemente le applicazioni Akka, viene utilizzato il "TestKit di Akka", che è un modulo appositamente progettato per il testing delle interazioni tra attori e per la simulazione dell'ambiente di esecuzione concorrente.

Il seguente listato mostra un esempio di specifica di test per il \textit{Resource Actor} del modulo \textit{Core}. Grazie al TestKit di Akka, è possibile simulare l'invio di messaggi in modo asincrono e verificare che il comportamento dell'attore sia conforme alle specifiche.

\lstinputlisting[language=Scala]{../assets/listings/AsyncTestingResourceSpec.scala}

Di seguito viene riportato l'output dei test eseguiti con SBT:

\begin{lstlisting}
[info] ResourceStateTest:
[info] Resource
[info] - should Merge correctly another resource
[info] JsonParseTest:
[info] Parser
[info] - should Parse correctly mainstays history JSON string
[info] AsyncTestingResourceSpec:
[info] Resource actor
[info] - should Ask resources to mainstay
[info] - should Send response when resource state is asked
[info] - should Set mainstays correctly and notify new resource state to mainstay
[info] AsyncTestingNodesObserverSpec:
[info] Nodes observer actor
[info] - should Send resource updates to mainstay correctly
[info] - should Send mainstay updates to mainstay correctly
[info] AsyncTestingMainstaySpec:
[info] Mainstay actor
[info] - should Register a resource state
[info] - should Register a new mainstay
[info] - should Sync with other mainstay
[info] Run completed in 1 second, 154 milliseconds.
[info] Total number of tests run: 10
[info] Suites: completed 5, aborted 0
[info] Tests: succeeded 10, failed 0, canceled 0, ignored 0, pending 0
[info] All tests passed.

\end{lstlisting}

\subsection{Testing del Servizio di Persistenza}

Postman\cite{postman} è un'applicazione che offre un'ampia gamma di strumenti per semplificare il processo di sviluppo, test e documentazione delle API. Le API sono punti di accesso che consentono a diverse applicazioni di comunicare tra loro, scambiando dati e funzionalità. Postman è ampiamente utilizzato dai team di sviluppo di software per testare, convalidare e interagire con le API in diversi scenari.

Il servizio di persistenza espone delle API web, le quali sono state testate utilizzando il software Postman (Figura: \ref{fig:postman}).

\begin{figure}[H]
    \caption{Testing delle API web del servizio di persistenza utilizzando Postman.}
    \includegraphics[width=\textwidth]{../assets/images/postman.jpg}
    \label{fig:postman}
\end{figure}

\subsection{Performance del Sistema Distribuito}

Per l'analisi delle performance del sistema distribuito si è scelto di considerare i tempi dello scambio dei messaggi tra uno dei nodi \textit{Resource} e il suo \textit{Mainstay} di riferimento. I risultati dell'analisi sono riportati in Tabella \ref{tab:analysis-specs}.

L'esecuzione è avvenuta in locale, su una macchina con le caratteristiche descritte in Tabella \ref{tab:machine-specs}.

\begin{figure}[H]
    \caption{Specifiche della macchina su cui è stata eseguita l'analisi.}
    \begin{center}
        \begin{tabular}{ | l | l | }
            \hline
            \textbf{OS}                   & NixOS 23.05       \\
            \hline
            \textbf{Linux kernel version} & 6.1.47            \\
            \hline
            \textbf{CPU}                  & AMD Ryzen 7 5700U \\
            \hline
            \textbf{Cores}                & 8                 \\
            \hline
            \textbf{Threads}              & 16                \\
            \hline
            \textbf{Base clock}           & 1.8GHz            \\
            \hline
            \textbf{Max boost clock}      & 4.3GHz            \\
            \hline
            \textbf{L2 cache}             & 4MB               \\
            \hline
            \textbf{L3 cache}             & 8MB               \\
            \hline
            \textbf{Memory}               & 15325MiB          \\
            \hline
        \end{tabular}
    \end{center}
    \label{tab:machine-specs}
\end{figure}

\begin{figure}[H]
    \caption{Risultati dell'analisi effettuata.}
    \begin{center}
        \begin{tabular}{ | l | l | }
            \hline
            \textbf{Numero di nodi \textit{Mainstay}} & 3       \\
            \hline
            \textbf{Numero di nodi \textit{Resource}} & 31      \\
            \hline
            \textbf{Numero di richieste effettuate}   & 101     \\
            \hline
            \textbf{Numero di risposte ottenute}      & 101     \\
            \hline
            \textbf{Tempo di risposta massimo}        & 3.228 s \\
            \hline
            \textbf{Tempo di risposta minimo}         & 0.002 s \\
            \hline
            \textbf{Tempo di risposta medio}          & 0.183 s \\
            \hline
        \end{tabular}
    \end{center}
    \label{tab:analysis-specs}
\end{figure}

\section{Piano di Lavoro}

Per lo sviluppo del progetto è stato adottato un processo ispirato alle tecniche agili proposte da Scrum.
La prima attività intrapresa è stata quella di analizzare i requisiti del sistema. Lo sviluppo delle funzionalità si è articolato secondo unità di tempo, chiamate Sprint, che scandivano il ritmo con il quale venivano effettuate riunioni e confronti tra gli sviluppatori. Al termine di ogni sprint settimanale, il team si riuniva per effettuare una retrospettiva su quanto svolto, per definire ciò che restava da sviluppare ed eventuali difficoltà incontrate. Durante ogni sprint, per organizzare il lavoro da svolgere, è stato prodotto uno sprint backlog: un artefatto che tiene traccia delle funzionalità da sviluppare. Per quanto riguarda la definizione dei task è stata utilizzata la funzionalità "issue boards" di GitLab\cite{GitLab}, in questo modo è stato possibile tener traccia dello stato di avanzamento del progetto.

Di seguito viene riportato il process backlog effettuato durante lo sviluppo del progetto.

\begin{itemize}
    \item Sprint 1
          \begin{itemize}
              \item Obiettivi
                    \begin{itemize}
                        \item Impostare il progetto SBT @ Barzi
                        \item Aggiungere CI per automatizzare i test @ Vissani
                        \item Aggiungere la configurazione di Akka Cluster @ Vissani
                        \item Definire l'architettura del Core e iniziare l'implementazione @ Vissani, Barzi
                        \item Definire le impostazioni di logging @ Vissani
                        \item Definire lo scopo e avviare l'implementazione del modulo River Monitor @ Barzi
                    \end{itemize}
              \item Revisione
                    \begin{itemize}
                        \item Alcuni comportamenti del Core devono essere corretti
                        \item Deve essere deciso come le risorse interagiscono con i Mainstay
                        \item I progetti delle risorse concrete devono essere definiti
                    \end{itemize}
          \end{itemize}
\end{itemize}

\begin{itemize}
    \item Sprint 2
          \begin{itemize}
              \item Obiettivi
                    \begin{itemize}
                        \item Trovare un modo per inviare le HashMap nei messaggi @ Vissani
                        \item Definire il comportamento di ResourceActor @ Vissani
                        \item Rendere ResourceActor consapevole dei Mainstay online @ Vissani
                        \item Avviare l'implementazione del Control Panel @ Vissani
                        \item Definire i moduli delle risorse concrete @ Barzi
                        \item Continuare l'implementazione di River Monitor integrandolo con ResourceActor @ Barzi
                    \end{itemize}
              \item Revisione
                    \begin{itemize}
                        \item Alcuni comportamenti del Core devono essere risolti
                        \item L'implementazione del Control Panel non è completa
                        \item Bisogna trovare un modo semplice per avviare l'intero sistema distribuito
                    \end{itemize}
          \end{itemize}
\end{itemize}

\begin{itemize}
    \item Sprint 3
          \begin{itemize}
              \item Obiettivi
                    \begin{itemize}
                        \item Stabilizzare le API del Core @ Vissani
                        \item Dockerizzare le applicazioni @ Barzi
                        \item Continuare l'implementazione di River Monitor @ Barzi
                        \item Migliorare il Control Panel @ Vissani
                        \item Avviare l'implementazione del servizio di persistenza @ Vissani
                    \end{itemize}
              \item Revisione
                    \begin{itemize}
                        \item Non è stato possibile Dockerizzare le applicazioni a causa di Swing
                        \item Il comportamento del servizio di persistenza deve essere testato
                        \item Le interazioni con il servizio di persistenza devono essere implementate
                    \end{itemize}
          \end{itemize}
\end{itemize}

\begin{itemize}
    \item Sprint 4
          \begin{itemize}
              \item Obiettivi
                    \begin{itemize}
                        \item Implementare l'interazione tra Core e servizio di persistenza @ Vissani
                        \item Implementare l'interazione tra Control Panel e servizio di persistenza @ Vissani
                        \item Avviare l'implementazione di Air Quality Monitor @ Barzi
                        \item Avviare l'implementazione di Acid Rain Monitor @ Barzi
                        \item Avviare l'implementazione di Noise Pollution Monitor @ Barzi
                    \end{itemize}
              \item Revisione
                    \begin{itemize}
                        \item La sincronizzazione tra i Mainstay deve essere migliorata
                        \item L'implementazione dei moduli delle risorse deve essere completata
                        \item Le scritture non necessarie sul servizio di persistenza devono essere ridotte
                    \end{itemize}
          \end{itemize}
\end{itemize}

\begin{itemize}
    \item Sprint 5
          \begin{itemize}
              \item Obiettivi
                    \begin{itemize}
                        \item Migliorare la sincronizzazione tra i Mainstay @ Vissani
                        \item Aggiungere la possibilità di scegliere la mappa della città @ Vissani
                        \item Aggiungere la documentazione @ Vissani, Barzi
                    \end{itemize}
          \end{itemize}
\end{itemize}

\section{Deployment e Avvio del Sistema}

\subsection{Requisiti}
\begin{itemize}
    \item Comuni:
          \begin{itemize}
              \item Scala 3.3.0
              \item Java openjdk 17.0.7
              \item SBT 1.x
              \item Docker
              \item Docker Compose
          \end{itemize}
    \item Linux:
          \begin{itemize}
              \item unzip
          \end{itemize}
    \item Windows:
          \begin{itemize}
              \item Powershell
              \item tar
          \end{itemize}
\end{itemize}

\subsection{Generazione degli Artefatti}

Per generare gli artefatti è necessario eseguire il seguente comando nella root del progetto:

\begin{lstlisting}
sbt assembly
\end{lstlisting}

Gli artefatti generati sono eseguibili nativi per Linux, Mac e Windows compressi in formato zip. Per ogni sotto-progetto viene generato un artefatto con il nome \textit{nome-sottoprogetto-0.1.0.zip}.

Per estrarre gli artefatti è necessario eseguire il seguente comando nella root del progetto:

Su Linux (bash):
\begin{lstlisting}
unzip ./nome-sottoprogetto/target/universal/nome-sottoprogetto-0.1.0.zip -d ./nome-sottoprogetto/target/
\end{lstlisting}

Su Windows (Powershell):
\begin{lstlisting}
tar -x -f ./nome-sottoprogetto/target/universal/nome-sottoprogetto-0.1.0.zip -C ./nome-sottoprogetto/target/
\end{lstlisting}

Per generare le immagini Docker necessarie al servizio di persistenza, eseguire:

\begin{lstlisting}[language=bash]
docker compose build
\end{lstlisting}

\subsection{Avvio del Sistema}

In generale, è meglio avviare il servizio di persistenza prima degli altri moduli, in modo che questi possano connettersi al servizio di persistenza al loro avvio. Per avviare il servizio di persistenza, eseguire:

\begin{lstlisting}[language=bash]
docker compose up
\end{lstlisting}

È sempre obbligatorio avviare almeno un'istanza del modulo \textit{Core}, altrimenti il cluster Akka non verrà avviato.
Per automatizzare l'avvio dei moduli del cluster Akka, è stato creato uno script, situato in \textit{./scripts/startup}, che compila, estrae ed avvia i moduli. Quindi, nel caso si voglia avviare il sistema con impostazioni predefinite, è sufficiente eseguire lo script fornito:

Su Linux (bash):

\begin{lstlisting}[language=bash]
./scripts/startup.sh
\end{lstlisting}

Su Windows (Powershell):

\begin{lstlisting}[language=bash]
./scripts/startup.bat
\end{lstlisting}

Altrimenti, è possibile avviare i singoli moduli manualmente, dopo averli compilati ed estratti, come descritto precedentemente.

Di seguito vengono riportati gli argomenti da passare ai moduli per il corretto funzionamento del sistema:
\begin{lstlisting}[language=bash]
core <NODE_PORT> <PERSISTENCE_SERVICE_HOST> <PERSISTENCE_SERVICE_PORT>
control-panel <NODE_PORT> <CITY_WIDTH> <CITY_HEIGHT> <MAP_FILE> <PERSISTENCE_SERVICE_HOST> <PERSISTENCE_SERVICE_PORT>
river-monitor-main <NODE_PORT> <RESOURCE_NAME> <THRESHOLD> <X_POSITION> <Y_POSITION> <<RESOURCES_TO_CHECK>...>
flood-sensor-main <NODE_PORT> <RESOURCE_NAME> <X_POSITION> <Y_POSITION>
view-main <NODE_PORT> <RESOURCE_NAME> <WIDTH> <HEIGHT> <<RESOURCES_TO_CHECK>...>
air-quality-monitor <NODE_PORT> <RESOURCE_NAME> <X_POSITION> <Y_POSITION> <SENSOR_URI>
acid-rain-monitor <NODE_PORT> <RESOURCE_NAME> <X_POSITION> <Y_POSITION>
noise-pollution-monitor <NODE_PORT> <RESOURCE_NAME> <X_POSITION> <Y_POSITION>
\end{lstlisting}

Di seguito viene fornito il un esempio di comando per avviare il modulo \textit{Core}:

Su Linux (bash):
\begin{lstlisting}
CESENA_MAP=$(readlink -f ./cesena-map.png)
PERSISTENCE_SERVICE_HOST="127.0.0.1"
PERSISTENCE_SERVICE_PORT="8080"
./core/target/core-0.1.0/bin/core 2551 ${PERSISTENCE_SERVICE_HOST} ${PERSISTENCE_SERVICE_PORT}
\end{lstlisting}

Su Windows (Powershell):
\begin{lstlisting}
call ./core/target/core-0.1.0/bin/core.bat 2551 127.0.0.1 8080
\end{lstlisting}

\section{Esempi di Utilizzo}

\subsection{Control Panel}

Il pannello di controllo è stato progettato per essere facilmente utilizzabile da qualsiasi tipo di utente. Le interazioni necessarie per visualizzare le informazioni desiderate sono state ridotte al minimo, in modo da rendere l'esperienza utente il più semplice possibile.

Il pannello di controllo dispone di quattro schermate:

\begin{itemize}
    \item \textbf{Mappa della città} (Figura \ref{fig:control-panel-map}): visualizza la posizione delle risorse nella città, indicandone il nome e lo stato (verde=online, rosso=offline).
    \item \textbf{Pannello delle informazioni} (Figura \ref{fig:control-panel-info}): visualizza in tempo reale le informazioni sullo stato delle risorse e dei Mainstay.
    \item \textbf{Pannello delle statistiche dei nodi Resource} (Figura \ref{fig:control-panel-resources-stats}): visualizza lo stato dei nodi Resource nel tempo.
    \item \textbf{Pannello delle statistiche dei nodi Mainstay}: visualizza lo stato dei nodi Mainstay nel tempo.
\end{itemize}

\begin{figure}[H]
    \caption{Control Panel: schermata della mappa della città.}
    \includegraphics[width=\textwidth]{../assets/images/control-panel-map.png}
    \label{fig:control-panel-map}
\end{figure}

\begin{figure}[H]
    \caption{Control Panel: schermata delle informazioni sullo stato dei nodi \textit{Resource} e dei nodi \textit{Mainstay}.}
    \includegraphics[width=\textwidth]{../assets/images/control-panel-info.png}
    \label{fig:control-panel-info}
\end{figure}

\begin{figure}[H]
    \caption{Control Panel: schermata delle statistiche dei nodi \textit{Resource}.}
    \includegraphics[width=\textwidth]{../assets/images/control-panel-resources-stats.png}
    \label{fig:control-panel-resources-stats}
\end{figure}

\section{Conclusioni}

%Recap what you did
In conclusione possiamo evidenziare come il progetto abbia raggiunto gli obiettivi prefissati, ovvero la realizzazione di un sistema distribuito per il monitoraggio di una Smart City. Il sistema è stato sviluppato in maniera modulare, in modo da poter essere facilmente esteso e mantenuto. Inoltre, il sistema è stato progettato per essere scalabile e resiliente, in modo da poter essere utilizzato in un contesto reale.

\subsection{Sviluppi Futuri}

%Recap what you did \emph{not}
Tra i vari miglioramenti a cui abbiamo pensato, i più significativi sono:
\begin{itemize}
    \item Utilizzo di una mappa geografica reale (simile a \textit{Google Maps}): Integrare una mappa geografica reale all'interno del sistema, consentendo di posizionare le risorse virtuali in base alle coordinate reali delle smart city. Questo migliorerebbe la precisione della modellazione e consentirebbe una rappresentazione più accurata dell'ambiente urbano.
    \item Sviluppo delle interfacce grafiche con applicazioni web in modo da renderle accessibili da dispositivi di vario genere (computer, smartphone, tablet, ecc.).;
    \item Possibilità per le risorse di tipo \textit{Act} di accedere allo storico dei dati rendendo trasparente il servizio di persistenza;
    \item Sostituzione dei sensori virtualizzati con sensori reali, in modo da poter effettuare un deployment su larga scala in un contesto reale.
    \item Implementazione di un sistema di autenticazione e autorizzazione per garantire la sicurezza del sistema.
    \item Implementazione di un sistema di notifiche per avvisare gli utenti in caso di eventi critici.
    \item Espansione delle funzionalità di analisi con l'ausilio di sistemi \textit{Big Data}: Introduzione di capacità di analisi avanzate per estrarre insight più profondi dai dati raccolti, ad esempio, analisi predittive per prevedere eventi futuri o rilevare anomalie in tempo reale.
    \item Implementazione di AI e Machine Learning: Integrazione di algoritmi di intelligenza artificiale e machine learning per l'automazione delle decisioni basate sui dati e per migliorare l'efficienza operativa delle smart city.
\end{itemize}

\subsection{Conoscenze Acquisite}

Durante la creazione del sistema distribuito, abbiamo acquisito una serie di competenze preziose nell'ambito dello sviluppo software utilizzando Scala 3 e Akka. In particolare, ci siamo concentrati sul paradigma ad attori, che ha dimostrato di essere fondamentale per la progettazione e l'implementazione di sistemi distribuiti altamente scalabili e resilienti. Grazie a Scala 3, abbiamo potuto sfruttare la potenza della programmazione funzionale e ottenere un codice più conciso ed espressivo. Akka, d'altra parte, ci ha fornito un'infrastruttura solida per implementare gli attori in modo efficiente, consentendo loro di comunicare in modo asincrono attraverso messaggi, garantendo al contempo la gestione dei fallimenti e la supervisione automatica degli attori stessi. Queste competenze ci hanno permesso di realizzare un sistema distribuito robusto e altamente performante, mettendo in evidenza il valore del paradigma ad attori nell'ambito dello sviluppo distribuito.

\newpage

\nocite{*} % Includes all references from the `references.bib` file
\bibliographystyle{plain}
\bibliography{references}

\end{document}
